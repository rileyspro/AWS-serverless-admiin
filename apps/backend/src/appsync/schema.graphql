# ****************************************************************************
# ABR
# ****************************************************************************
type ABNInformation {
  abn: String!
  abnStatus: String!
  abnStatusEffectiveFrom: String!
  acn: String!
  addressDate: String
  addressPostcode: String
  addressState: String
  businessName: [String]
  entityName: String
  entityTypeCode: String
  entityTypeName: String
  gst: String
  message: String
  type: EntityType
}

type AbrNameSearchInformation {
  abn: String!
  abnStatus: String!
  isCurrent: Boolean!
  name: String!
  nameType: String!
  postcode: String!
  state: String!
}

type ModelAbrNameSearchInformationConnection @aws_iam @aws_cognito_user_pools {
  items: [AbrNameSearchInformation]!
}

# ****************************************************************************
# ACTIVITY
# ****************************************************************************
type Activity @aws_iam @aws_cognito_user_pools {
  id: ID!
  compositeId: ID!
  userId: ID
  entityId: ID
  type: ActivityType!
  message: String
  metadata: ActivityMetadata
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

enum ActivityType {
  TASK
  REWARD
}

type ActivityMetadata {
  name: String
}

type ModelActivityConnection @aws_iam @aws_cognito_user_pools {
  items: [Activity]!
  nextToken: String
}

input ModelActivityFilterInput {
  userId: ModelIDInput
  entityId: ModelIDInput
  type: ModelActivityTypeInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelActivityFilterInput]
  or: [ModelActivityFilterInput]
  not: ModelActivityFilterInput
}

input ModelActivityTypeInput {
  eq: ActivityType
  ne: ActivityType
}

# ****************************************************************************
# ADDRESS
# ****************************************************************************
type Address @aws_iam @aws_cognito_user_pools {
  #contactName: String
  #contactNumber: AWSPhone
  #address1: String!
  #address2: String
  #country: String!
  #countryCode: String
  #state: String!
  #stateCode: String
  #city: String!
  #postalCode: String!
  addressId: ID
  placeId: ID
  contactName: String
  contactNumber: AWSPhone
  address1: String
  unitNumber: String
  streetNumber: String
  streetName: String!
  streetType: String
  city: String!
  country: String!
  countryCode: String
  state: String!
  stateCode: String
  postalCode: String!
}

input AddressInput {
  addressId: ID
  contactName: String
  contactNumber: AWSPhone
  address1: String!
  address2: String
  country: String!
  countryCode: String
  streetNumber: String
  streetName: String!
  unitNumber: String
  streetType: String
  city: String!
  state: String!
  stateCode: String
  postalCode: String!
}

# ****************************************************************************
# ADMIN
# ****************************************************************************
type Admin @aws_iam @aws_cognito_user_pools {
  firstName: String!
  lastName: String!
  email: AWSEmail!
  phone: AWSPhone
  role: AdminRole
  hasAccessed: Boolean
  createdBy: ID
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  id: ID!
  owner: String
}

enum AdminRole {
  SuperAdmins
  Admins
}

input CreateAdminInput {
  firstName: String!
  lastName: String!
  email: AWSEmail!
  role: AdminRole
}

input DeleteAdminInput {
  id: ID!
}

type ModelAdminConnection @aws_iam @aws_cognito_user_pools {
  items: [Admin]!
  nextToken: String
}

input ModelAdminRoleInput {
  eq: AdminRole
  ne: AdminRole
}

input ModelAdminFilterInput {
  firstName: ModelStringInput
  lastName: ModelStringInput
  email: ModelStringInput
  phone: ModelStringInput
  role: ModelAdminRoleInput
  hasAccessed: ModelBooleanInput
  createdBy: ModelIDInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelAdminFilterInput]
  or: [ModelAdminFilterInput]
  not: ModelAdminFilterInput
}

input ModelAdminConditionInput {
  firstName: ModelStringInput
  lastName: ModelStringInput
  email: ModelStringInput
  phone: ModelStringInput
  role: ModelAdminRoleInput
  hasAccessed: ModelBooleanInput
  createdBy: ModelIDInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelAdminConditionInput]
  or: [ModelAdminConditionInput]
  not: ModelAdminConditionInput
}

input UpdateAdminInput {
  firstName: String
  lastName: String
  email: AWSEmail
  phone: AWSPhone
  role: AdminRole
  hasAccessed: Boolean
  createdBy: ID
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  id: ID!
}

# ****************************************************************************
# AUTOCOMPLETE RESULT
# ****************************************************************************
type AutocompleteResult {
  id: ID!
  value: String!
  label: String!
  info: String
  type: AutocompleteType!
  searchName: String!
  metadata: AutocompleteResultMetadata
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type GetAutoCompleteResult {
  entity: Entity
  contact: Contact
}

enum AutocompleteType {
  ENTITY
  TAX
}

input ModelAutocompleteResultFilterInput {
  searchName: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelEntityFilterInput]
  or: [ModelEntityFilterInput]
  not: ModelEntityFilterInput
}

type ModelAutocompleteResultConnection @aws_iam @aws_cognito_user_pools {
  items: [AutocompleteResult]!
  nextToken: String
}

enum PaymentProvider {
  ZAI
  APP_STORE
  GOOGLE_PLAY
}

type AutocompleteResultMetadata {
  subCategory: String
  payoutMethod: PayoutMethod
}

enum PayoutMethod {
  BANK
  BPAY
}

# ****************************************************************************
# BENEFICIAL OWNER
# ****************************************************************************
type BeneficialOwner @aws_iam @aws_cognito_user_pools {
  id: ID!
  firstName: String
  lastName: String
  name: String
  providerEntityId: ID! # Frankieone entityId
  verificationStatus: VerificationStatus!
  verificationAttempt: Int
  createdBy: ID
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input UpdateBeneficialOwnerInput {
  id: ID!
  firstName: String
  lastName: String
  name: String
  providerEntityId: ID # Frankieone entityId
  verificationStatus: VerificationStatus
  verificationAttempt: Int
  updatedAt: AWSDateTime
  lastCheckedAt: AWSDateTime
}

enum VerificationStatus {
  UNCHECKED
  PASS
  FAIL
  PASS_MANUAL
  FAIL_MANUAL
  REFER
  WAIT
  ARCHIVED
  INACTIVE
}

type ModelBeneficialOwnersConnection @aws_iam @aws_cognito_user_pools {
  items: [BeneficialOwner]!
  nextToken: String
}

# ****************************************************************************
# CLIENTS
# ****************************************************************************
input CreateClientInput {
  entityId: ID!
  client: ClientInput!
  entity: CreateEntityInput
}

input ClientInput {
  firstName: String!
  lastName: String!
  name: String!
  email: AWSEmail!
  phone: AWSPhone!
}

# ****************************************************************************
# CONTACTS
# ****************************************************************************
type Contact @aws_iam @aws_cognito_user_pools {
  id: ID!
  entityId: ID!
  entityType: EntityType
  firstName: String
  lastName: String
  email: AWSEmail
  phone: AWSPhone
  taxNumber: String
  name: String
  legalName: String
  companyName: String
  searchName: String # is either companyName or first and last name
  status: ContactStatus
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  contactType: ContactType
  bank: ContactBankAccount
  bpay: ContactBpay
  bulkUploadFileKey: String
  owner: ID
}

type ContactBankAccount {
  id: ID
  accountName: String!
  bankName: String
  accountNumber: String!
  routingNumber: String!
  holderType: BankHolderType
  accountType: BankAccountType
  country: String
}

type ContactBpay {
  billerCode: Int
  referenceNumber: String
}

enum ContactType {
  CLIENT
  NORMAL
}

input ContactBankAccountInput {
  accountName: String!
  bankName: String
  accountNumber: String!
  routingNumber: String!
  holderType: BankHolderType
  accountType: BankAccountType
  country: String
}

input CreateContactInput {
  entityId: ID!
  firstName: String!
  lastName: String!
  email: AWSEmail!
  phone: AWSPhone
  status: ContactStatus
  companyName: String
  taxNumber: String
  bank: ContactBankAccountInput
  bpay: ContactBpayInput
}

input UpdateContactInput {
  id: ID!
  entityId: ID
  firstName: String
  lastName: String
  email: AWSEmail
  phone: AWSPhone
  #  companyName: String
  #  taxNumber: String
  status: ContactStatus
  bank: ContactBankAccountInput
  bpay: ContactBpayInput
}

input ContactBpayInput {
  billerCode: Int
  referenceNumber: String
}

input CreateContactBulkImportInput {
  entityId: ID!
  fileKey: String!
  fields: ContactFieldsInput!
}

input ContactFieldsInput {
  firstName: String!
  lastName: String!
  email: String!
  phone: String!
  companyName: String
  taxNumber: String
  billerCode: String
  referenceNumber: String
  accountName: String
  bankName: String
  accountNumber: String
  routingNumber: String
}

enum ContactStatus {
  ACTIVE
  ARCHIVED
}

type ModelContactConnection @aws_iam @aws_cognito_user_pools {
  items: [Contact]!
  nextToken: String
}

input ModelContactTypeInput {
  eq: ContactType
  ne: ContactType
}

input ModelContactStatusInput {
  eq: ContactStatus
  ne: ContactStatus
}

input ModelContactFilterInput {
  searchName: ModelStringInput
  type: ModelContactTypeInput
  status: ModelContactStatusInput
  and: [ModelContactFilterInput]
  or: [ModelContactFilterInput]
  not: ModelContactFilterInput
}

# ****************************************************************************
# CONTACT GUEST
# ****************************************************************************
type ContactGuest @aws_iam @aws_cognito_user_pools {
  id: ID!
  firstName: String
  lastName: String
  name: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# ****************************************************************************
# CONVERSATION
# ****************************************************************************
type Conversation @aws_iam @aws_cognito_user_pools {
  title: String
  image: Image
  country: String
  messages(
    createdAt: ModelStringKeyConditionInput
    filter: ModelMessageFilterInput
    sortDirection: ModelSortDirection
    limit: Int
    nextToken: String
  ): ModelMessageConnection
  userConversations(
    createdAt: ModelStringKeyConditionInput
    filter: ModelUserConversationFilterInput
    sortDirection: ModelSortDirection
    limit: Int
    nextToken: String
  ): ModelUserConversationConnection
  users: [String]
  readBy: [String]
  createdBy: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  id: ID!
}

type ModelConversationConnection @aws_iam @aws_cognito_user_pools {
  items: [Conversation]!
  nextToken: String
}

input ModelConversationFilterInput {
  title: ModelStringInput
  country: ModelStringInput
  users: ModelStringInput
  readBy: ModelStringInput
  createdBy: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelConversationFilterInput]
  or: [ModelConversationFilterInput]
  not: ModelConversationFilterInput
}

input ModelConversationConditionInput {
  title: ModelStringInput
  country: ModelStringInput
  users: ModelStringInput
  readBy: ModelStringInput
  createdBy: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelConversationConditionInput]
  or: [ModelConversationConditionInput]
  not: ModelConversationConditionInput
}

input CreateConversationInput {
  title: String
  image: ImageInput
  country: String
  users: [String]
  readBy: [String]
  createdBy: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  id: ID
}

input UpdateConversationInput {
  title: String
  image: ImageInput
  country: String
  users: [String]
  readBy: [String]
  createdBy: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  id: ID!
}

input DeleteConversationInput {
  id: ID!
}

input ModelSubscriptionConversationFilterInput {
  title: ModelSubscriptionStringInput
  country: ModelSubscriptionStringInput
  readBy: ModelSubscriptionStringInput
  createdBy: ModelSubscriptionStringInput
  createdAt: ModelSubscriptionStringInput
  updatedAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionConversationFilterInput]
  or: [ModelSubscriptionConversationFilterInput]
}

# ****************************************************************************
# DOCUMENT ANALYSIS
# ****************************************************************************
type DocumentAnalysis @aws_iam @aws_cognito_user_pools {
  id: ID!
  entityId: ID!
  jobId: ID!
  fileKey: String!
  status: DocumentAnalysisStatus!
  metadata: DocumentAnalysisMetadata
  createdBy: ID
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

enum DocumentAnalysisStatus {
  IN_PROGRESS
  COMPLETED
}

type DocumentAnalysisContact {
  firstName: String
  lastName: String
  email: AWSEmail
  phone: AWSPhone
  companyName: String
  taxNumber: String
}

type DocumentAnalysisLineItem {
  description: String
  quantity: Float
  unitPrice: Int
  price: Int
  productCode: String
}

type DocumentAnalysisTask {
  reference: String
  dueAt: AWSDate
  gstInclusive: Boolean
  noteForSelf: String
  noteForOther: String
  amount: Int
  gstAmount: Int
  lineItems: [DocumentAnalysisLineItem]
  numberOfPayments: Int
  paymentFrequency: PaymentFrequency
  shippingAmount: Int
}

type DocumentAnalysisBankAccount {
  accountNumber: String
  routingNumber: String
}

type DocumentAnalysisPayment {
  bpay: ContactBpay
  bank: DocumentAnalysisBankAccount
}

type DocumentAnalysisMetadata {
  matchedContact: Contact
  potentialContacts: [Contact]
  matchedEntity: Entity
  newContact: DocumentAnalysisContact
  payment: DocumentAnalysisPayment
  task: DocumentAnalysisTask
}

input CreateDocumentAnalysisInput {
  entityId: ID!
  fileKey: String!
}

# TODO: Remove  providerBillUserCompanyId: ID
#          providerBankAccountId: ID
#          providerDigitalWalletId: ID
#          providerBpayCrn: String

# ****************************************************************************
# ENTITY
# ****************************************************************************
type Entity @aws_iam @aws_cognito_user_pools {
  id: ID!
  type: EntityType!
  taxNumber: String
  companyNumber: String
  billerCode: Int
  name: String!
  legalName: String
  searchName: String # is either companyName or first and last name
  address: Address
  logo: Image
  entityBeneficialOwners(
    sortDirection: ModelSortDirection
    limit: Int
    nextToken: String
  ): ModelEntityBeneficialOwnerConnection
  entityUsers(
    filter: ModelEntityUserFilterInput
    sortDirection: ModelSortDirection
    limit: Int
    nextToken: String
  ): ModelEntityUserConnection
  gstRegistered: Boolean
  providerEntityId: ID
  providerCompanyId: ID
  providerBillUserCompanyId: ID
  providerBankAccountId: ID
  providerDigitalWalletId: ID
  providerBpayCrn: String
  contact: EntityContact
  paymentMethods(
    filter: ModelPaymentMethodFilterInput
    sortDirection: ModelSortDirection
    limit: Int
    nextToken: String
  ): ModelPaymentMethodConnection
  paymentMethodId: String
  paymentUserId: String
  disbursementMethodId: String
  receivingAccounts(
    filter: ModelPaymentMethodFilterInput
    sortDirection: ModelSortDirection
    limit: Int
    nextToken: String
  ): ModelPaymentMethodConnection
  ubosCreated: Boolean
  numUbosCreated: Int
  subCategory: String
  clientsStatus: EntityClientsStatus
  ocrEmail: AWSEmail
  verificationStatus: VerificationStatus
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  owner: String!
  referredBy: ID
}

type EntityContact @aws_iam @aws_cognito_user_pools {
  firstName: String
  lastName: String
  email: AWSEmail
  phone: AWSPhone
  role: String
}

enum EntityType {
  COMPANY
  TRUST
  NOT_FOR_PROFIT
  SELF_MANAGED_SUPER_FUND
  BPAY
}

enum EntityClientsStatus {
  ENABLED
  DISABLED
  REVIEW
  DECLINED
}

input CreateEntityInput {
  type: EntityType!
  taxNumber: String
  name: String!
  firstName: String
  lastName: String
  address: AddressInput
  logo: ImageInput
  isFirm: Boolean
}

# TODO: should updateEntity be split for iam to trigger backend prop updates - ubosCreated & verification status
# TODO: pepCheckStatus
input UpdateEntityInput {
  id: ID!
  type: EntityType
  taxNumber: String
  name: String
  address: AddressInput
  logo: ImageInput
  paymentMethodId: ID
  disbursementMethodId: ID
  ubosCreated: Boolean
  numUbosCreated: Int
  verificationStatus: VerificationStatus
  pepCheckStatus: String
  firstName: String
  lastName: String
  legalName: String
  contact: EntityContactInput
  gstRegistered: Boolean
  role: String
  isFirm: Boolean
  # createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input EntityContactInput {
  firstName: String
  lastName: String
  email: AWSEmail
  phone: AWSPhone
}

input UpdateOnboardingEntityInput {
  owner: ID!
  type: EntityType
  taxNumber: String
  name: String
  address: AddressInput
  logo: ImageInput
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type ModelEntityConnection @aws_iam @aws_cognito_user_pools {
  items: [Entity]!
  nextToken: String
}

input ModelEntityTypeInput {
  eq: EntityType
  ne: EntityType
}

input ModelEntityFilterInput {
  name: ModelStringInput
  searchName: ModelStringInput
  taxNumber: ModelStringInput
  address: ModelStringInput
  type: ModelEntityTypeInput
  owner: ModelIDInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelEntityFilterInput]
  or: [ModelEntityFilterInput]
  not: ModelEntityFilterInput
}

input ModelEntityConditionInput {
  name: ModelStringInput
  taxNumber: ModelStringInput
  address: ModelStringInput
  type: ModelEntityTypeInput
  owner: ModelIDInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelEntityConditionInput]
  or: [ModelEntityConditionInput]
  not: ModelEntityConditionInput
}

input DeleteEntityInput {
  id: ID!
}

type ModelEntityTaskConnection @aws_iam @aws_cognito_user_pools {
  items: [Task]!
  toNextToken: String
  fromNextToken: String
}

input LookupEntityOwnershipInput {
  entityId: ID!
}

type LookupEntityOwnershipResult {
  async: Boolean
}

input CreateVerificationTokenInput {
  beneficialOwnerId: ID!
  entityId: ID!
  preset: VerificationTokenPreset
}

enum VerificationTokenPreset {
  SMART_UI
  ONE_SDK
}

type VerificationUiToken {
  token: String!
}

# ****************************************************************************
# ENTITY GUEST
# ****************************************************************************
type EntityGuest @aws_iam @aws_cognito_user_pools {
  id: ID!
  name: String!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# ****************************************************************************
# ENTITY BENEFICIAL OWNER
# ****************************************************************************
type EntityBeneficialOwner @aws_iam @aws_cognito_user_pools {
  entityId: ID!
  beneficialOwnerId: ID!
  beneficialOwner: BeneficialOwner
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  owner: String
}

type ModelEntityBeneficialOwnerConnection @aws_iam @aws_cognito_user_pools {
  items: [EntityBeneficialOwner]
  nextToken: String
}

# ****************************************************************************
# JOB
# ****************************************************************************
type Job @aws_iam @aws_cognito_user_pools {
  id: ID!
  entityId: ID!
  jobId: ID
  status: JobStatus
  type: JobType
  createdBy: ID
  expiresAt: AWSDateTime
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

enum JobStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
}

enum JobType {
  INVOICE_QUERIES
  INVOICE_ANALYSIS
}

# ****************************************************************************
# ENTITY USER
# ****************************************************************************
type EntityUser @aws_iam @aws_cognito_user_pools {
  id: ID!
  entityId: ID!
  userId: ID!
  invitedEmail: AWSEmail
  referredBy: ID
  invitedEntityId: ID
  firmEntityId: ID
  firstName: String
  lastName: String
  role: EntityUserRole
  paymentsEnabled: Boolean
  entitySearchName: String # is either companyName or first and last name
  entity: Entity
  searchName: String
  createdBy: ID
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  status: EntityUserStatus
}

enum EntityUserStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum EntityUserRole {
  OWNER
  ADMIN
  ACCOUNTANT
  CONTRIBUTOR
}

type ModelEntityUserConnection @aws_iam @aws_cognito_user_pools {
  items: [EntityUser]!
  nextToken: String
}

input EntityUserRoleFilter {
  eq: EntityUserRole
  ne: EntityUserRole
}

input ModelEntityUserFilterInput {
  entityId: ModelIDInput
  # userId: ModelIDInput
  entitySearchName: ModelStringInput
  searchName: ModelStringInput
  role: EntityUserRoleFilter
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelEntityUserFilterInput]
  or: [ModelEntityUserFilterInput]
  not: ModelEntityUserFilterInput
}

input CreateEntityUserInput {
  entityId: ID!
  userId: ID!
  firstName: String
  lastName: String
  email: AWSEmail
  role: CreateEntityUserRole
  paymentsEnabled: Boolean
}

enum RewardStatus {
  BRONZE
  SILVER
  GOLD
  PLATINUM
  DIAMOND
}

input AcceptDenyEntityUserStatusInput {
  entityId: ID!
  userId: ID!
  status: EntityUserStatus!
}

input RegenerateEntityOcrEmailInput {
  entityId: ID!
}

input sendReferralInvitationEmailInput {
  email: [AWSEmail!]!
}

input UpdateEntityUserInput {
  entityId: ID!
  userId: ID!
  paymentsEnabled: Boolean
}

enum CreateEntityUserRole {
  ADMIN
  ACCOUNTANT
  CONTRIBUTOR
}

input DeleteEntityUserInput {
  entityId: ID!
  userId: ID!
}

# ****************************************************************************
# FRANKIEONE
# ****************************************************************************
type BusinessLookupResult {
  name: String
  legalNames: [String]
  businessNames: [String]
  mainNames: [String]
  tradingNames: [String]
  score: String
  state: String
  postalCode: String
  type: String
  abn: String
  acn: String
  isActive: Boolean
}

# ****************************************************************************
# IMAGE
# ****************************************************************************
type Image @aws_iam @aws_cognito_user_pools {
  alt: String
  identityId: String
  key: String!
  level: S3UploadLevel!
  type: String
}

input ImageInput {
  alt: String
  identityId: String
  key: String!
  level: S3UploadLevel!
  type: String
}

# ****************************************************************************
# IN-APP PURCHASE
# ****************************************************************************
input VerifyIAPInput {
  receipt: ID!
  service: PaymentProvider!
  subscriptionId: String
}

# ****************************************************************************
# MESSAGE
# ****************************************************************************
type Message @aws_iam @aws_cognito_user_pools {
  conversationId: ID!
  text: String
  attachments: [S3Upload]
  users: [String]!
  receiver: ID!
  sender: ID!
  createdBy: String!
  readBy: [String]
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime
  id: ID!
  conversationMessagesId: ID
}

type ModelMessageConnection @aws_iam @aws_cognito_user_pools {
  items: [Message]!
  nextToken: String
}

input ModelMessageFilterInput {
  conversationId: ModelIDInput
  text: ModelStringInput
  users: ModelStringInput
  receiver: ModelIDInput
  sender: ModelIDInput
  createdBy: ModelStringInput
  readBy: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelMessageFilterInput]
  or: [ModelMessageFilterInput]
  not: ModelMessageFilterInput
  conversationMessagesId: ModelIDInput
}

input ModelMessageConditionInput {
  conversationId: ModelIDInput
  text: ModelStringInput
  users: ModelStringInput
  receiver: ModelIDInput
  sender: ModelIDInput
  createdBy: ModelStringInput
  readBy: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelMessageConditionInput]
  or: [ModelMessageConditionInput]
  not: ModelMessageConditionInput
  conversationMessagesId: ModelIDInput
}

input CreateMessageInput {
  conversationId: ID!
  text: String
  attachments: [S3UploadInput]
  users: [String]!
  receiver: ID!
  sender: ID!
  createdBy: String!
  readBy: [String]
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  id: ID
  conversationMessagesId: ID
}

input UpdateMessageInput {
  conversationId: ID
  text: String
  attachments: [S3UploadInput]
  users: [String]
  receiver: ID
  sender: ID
  createdBy: String
  readBy: [String]
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  id: ID!
  conversationMessagesId: ID
}

input ModelSubscriptionMessageFilterInput {
  conversationId: ModelSubscriptionIDInput
  text: ModelSubscriptionStringInput
  receiver: ModelSubscriptionIDInput
  sender: ModelSubscriptionIDInput
  createdBy: ModelSubscriptionStringInput
  readBy: ModelSubscriptionStringInput
  createdAt: ModelSubscriptionStringInput
  updatedAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionMessageFilterInput]
  or: [ModelSubscriptionMessageFilterInput]
}

# ****************************************************************************
# NOTIFICATION
# ****************************************************************************
type Notification @aws_iam @aws_cognito_user_pools {
  id: ID!
  title: String
  message: String
  status: NotificationStatus
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  type: String
  owner: ID!
}

enum NotificationStatus {
  UNREAD
  READ
}

input CreateNotificationInput {
  title: String
  message: String
  status: NotificationStatus
  type: String
  owner: ID!
}

input UpdateNotificationInput {
  id: ID!
  status: NotificationStatus!
}

type ModelNotificationConnection @aws_iam @aws_cognito_user_pools {
  items: [Notification]!
  nextToken: String
}

input NotificationStatusInput {
  eq: NotificationStatus
  ne: NotificationStatus
}

input ModelNotificationFilterInput {
  status: NotificationStatusInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  type: ModelStringInput
  and: [ModelNotificationFilterInput]
  or: [ModelNotificationFilterInput]
  not: ModelNotificationFilterInput
}

# ****************************************************************************
# OPTIONS
# ****************************************************************************
type Option @aws_iam @aws_cognito_user_pools {
  name: String
  label: String!
  value: String!
  group: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  id: ID!
}

type ModelOptionConnection @aws_iam @aws_cognito_user_pools {
  items: [Option]!
  nextToken: String
}

input ModelOptionFilterInput {
  name: ModelStringInput
  label: ModelStringInput
  value: ModelStringInput
  group: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelOptionFilterInput]
  or: [ModelOptionFilterInput]
  not: ModelOptionFilterInput
}

input ModelOptionConditionInput {
  name: ModelStringInput
  label: ModelStringInput
  value: ModelStringInput
  group: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelOptionConditionInput]
  or: [ModelOptionConditionInput]
  not: ModelOptionConditionInput
}

input CreateOptionInput {
  name: String
  label: String!
  value: String!
  group: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  id: ID
}

input UpdateOptionInput {
  name: String
  label: String
  value: String
  group: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  id: ID!
}

input DeleteOptionInput {
  id: ID!
}

# ****************************************************************************
# PAY IN PAYMENT
# ****************************************************************************
type PayInPayment @aws_iam @aws_cognito_user_pools {
  id: ID!
  entityId: ID!
  amount: Int
  paymentType: PaymentType
  status: PayInPaymentStatus
  taskPayments: [TaskPayment!]!
  scheduledAt: AWSDate
  createdBy: ID
  paymentUserId: ID!
  receivedAt: AWSDateTime
  paidOutAt: AWSDateTime
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type TaskPayment {
  id: ID!
  paymentType: PaymentType!
  installments: Int!
  scheduledAt: AWSDate!
}

enum PayInPaymentStatus {
  PENDING_PAYID_TRANSFER
  RECEIVED_PAYID_TRANSFER
  PAID_OUT_PAYID_TRANSFER
}

# ****************************************************************************
# PAYMENT
# ****************************************************************************
type Payment @aws_iam @aws_cognito_user_pools {
  id: ID!
  taskId: ID
  entityId: ID
  payInPaymentId: ID
  providerTransactionId: String
  paymentProvider: PaymentProvider
  disbursementId: ID
  fromId: ID!
  fromType: FromToType!
  toId: ID
  toType: FromToType
  buyerId: ID
  sellerId: ID
  entityIdTo: ID
  amount: Int
  netAmount: Int
  payerFees: Int
  totalAmount: Int
  gstAmount: Int
  # bills: [BillsPaymentType!]!
  installment: Int
  installments: Int
  feeAmount: Int
  paymentType: PaymentType
  taxAmount: Int
  currency: String
  # feeId: ID
  feeIds: [ID]
  ipAddress: String
  status: PaymentStatus!
  payerUserStatus: PayerUserStatus
  declinedReason: String
  scheduledAt: AWSDate
  paidAt: AWSDateTime
  declinedAt: AWSDateTime
  createdAt: AWSDateTime
  receivedAt: AWSDateTime
  paidOutAt: AWSDateTime
  updatedAt: AWSDateTime
  voidedAt: AWSDateTime
  owner: String
}

enum PaymentStatus {
  GUEST_SCHEDULED
  SCHEDULED
  PENDING_USER_CONFIRMATION
  PENDING_PAYTO_AGREEMENT_CREATION
  REJECTED_PAYTO_PAYMENT_RETRYABLE
  REJECTED_PAYTO_PAYMENT_NOT_RETRYABLE
  PENDING_PAYID_TRANSFER
  RECEIVED_PAYID_TRANSFER
  PENDING_PAYMENT_INITIATION
  PAYMENT_INITIATION_REJECTED
  USER_CONFIRMED
  DECLINED
  PENDING
  PAYMENT_REQUIRED
  WIRE_PENDING
  PAYMENT_PENDING
  PAYMENT_HELD
  PAYMENT_AUTHORIZED
  VOID_PENDING
  VOIDED
  FRAUD_HOLD
  PAYMENT_DEPOSITED
  WORK_COMPLETED
  PROBLEM_FLAGGED
  PROBLEM_RESOLVE_REQUESTED
  PROBLEM_ESCALATED
  COMPLETED
  CANCELLED
  REFUNDED
  REFUND_PENDING
  REFUND_FLAGGED
  OFF_PLATFORM_REFUNDED
  PARTIAL_COMPLETED
  PARTIAL_PAID
  OFF_PLATFORM_CHARGEDBACK
}

enum PayerUserStatus {
  USER
  NON_USER
}

input ConfirmPaymentInput {
  payments: [String!]!
}

input CreatePaymentInput {
  entityId: ID!
  paymentMethodId: String!
  billPayments: [BillsPaymentInput!]!
  idempotencyKey: ID
}

input CreatePaymentGuestInput {
  entityId: ID!
  taskId: ID!
  paymentMethodId: String!
}

input CreatePaymentScheduledGuestInput {
  paymentId: ID!
  paymentMethodId: String!
}

input CreatePaymentPayIdInput {
  entityId: ID!
  billPayments: [BillsPaymentInput!]!
  idempotencyKey: ID
}

type EntityPayId @aws_iam @aws_cognito_user_pools {
  transferAmount: Int
  payId: String
  payIdReference: String
  currency: String
}

input CancelPaymentPayIdInput {
  entityId: ID!
  payInPaymentId: ID!
}

input CreateTaskPaymentInput {
  taskId: ID!
  entityId: ID!
  paymentMethodId: String!
}

input BillsPaymentInput {
  id: ID!
  paymentType: PaymentType!
  installments: Int!
  scheduledAt: AWSDate!
  paymentFrequency: PaymentFrequency
}

enum PaymentType {
  PAY_NOW
  SCHEDULED
  INSTALLMENTS
}

input RetryPaymentInput {
  id: ID!
  paymentMethodId: String!
}

type ModelPaymentConnection @aws_iam @aws_cognito_user_pools {
  items: [Payment]!
  nextToken: String
}

input ModelPaymentFilterInput {
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelPaymentFilterInput]
  or: [ModelPaymentFilterInput]
  not: ModelPaymentFilterInput
}

# ****************************************************************************
# PAYMENT GUEST
# ****************************************************************************
type PaymentGuest @aws_iam @aws_cognito_user_pools {
  id: ID!
  entityId: ID!
  taskId: ID
  amount: Int
  installment: Int
  installments: Int
  feeAmount: Int
  paymentType: PaymentType
  taxAmount: Int
  currency: String
  feeId: ID
  status: PaymentStatus!
  payerUserStatus: PayerUserStatus
  scheduledAt: AWSDate
  paidAt: AWSDateTime
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  owner: String
}

# ****************************************************************************
# PAYMENT METHOD
# ****************************************************************************
type PaymentMethod @aws_iam @aws_cognito_user_pools {
  id: ID!
  paymentMethodType: PaymentMethodType!
  type: String
  fullName: String
  number: String
  expMonth: String
  expYear: String
  accountName: String
  bankName: String
  accountNumber: String
  routingNumber: String
  holderType: BankHolderType
  accountType: BankAccountType
  status: PaymentMethodStatus
  accountDirection: AccountDirection
  # identityId: ID
  expiresAt: AWSDateTime
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  # owner: String
}

enum BankHolderType {
  personal
  business
}

enum BankAccountType {
  savings
  checking
}

# input PaymentMethodInput {
#   id: ID!
#   paymentMethodType: PaymentMethodType!
#   primary: Boolean
#   createdAt: AWSDateTime
#   updatedAt: AWSDateTime
# }

input CreatePaymentMethodInput {
  entityId: String!
  paymentMethodId: String!
  paymentMethodType: PaymentMethodType!
  accountDirection: AccountDirection
  # primary: Boolean
}

input UpdatePaymentMethodInput {
  id: ID!
  # primary: Boolean
  status: PaymentMethodStatus
}

input ModelPaymentMethodFilterInput {
  paymentMethodType: ModelPaymentMethodTypeInput
  type: ModelStringInput
  # primary: ModelBooleanInput
  status: ModelPaymentMethodStatusInput
  accountDirection: ModelAccountDirectionInput
  expiresAt: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelPaymentMethodFilterInput]
  or: [ModelPaymentMethodFilterInput]
  not: ModelPaymentMethodFilterInput
}

type ModelPaymentMethodConnection @aws_iam @aws_cognito_user_pools {
  items: [PaymentMethod]!
  nextToken: String
}

enum PaymentMethodType {
  CARD
  BANK
  PAYTO
  PAYID
}

enum PaymentMethodStatus {
  ACTIVE
  ARCHIVED
}

enum AccountDirection {
  PAYMENT
  DISBURSEMENT
}

input ModelPaymentMethodTypeInput {
  eq: PaymentMethodType
  ne: PaymentMethodType
}

input ModelAccountDirectionInput {
  eq: AccountDirection
  ne: AccountDirection
}

input ModelPaymentMethodStatusInput {
  eq: PaymentMethodStatus
  ne: PaymentMethodStatus
}

# ****************************************************************************
# PAYMENT ACCOUNT
# ****************************************************************************

# TODO: Probably won't be exposed to the client, remove from schema?
type PaymentAccount @aws_iam {
  id: ID!
  compositeId: ID # zaiUserId#billerCode#reference OR userId#bsb#accountNumber
  entityId: ID!
  idOwner: ID!
  idOwnerType: IdOwnerType!
  reference: String
  bpayReferenceNumber: String
  billerCode: Int
  paymentUserId: ID!
  providerBpayAccountId: ID!
  providerWalletId: ID!
  paymentAccountType: PaymentAccountType!
  direction: PaymentAccountDirection!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

enum IdOwnerType {
  ENTITY
  CONTACT
}

enum PaymentAccountType {
  BPAY
}

enum PaymentAccountDirection {
  PAY_IN
  PAY_OUT
}

# ****************************************************************************
# PUSH NOTIFICATION
# ****************************************************************************
input CreatePushNotificationInput {
  starId: ID
  title: String
  message: String
}

# ****************************************************************************
# RATINGS
# ****************************************************************************
type Rating @aws_iam @aws_cognito_user_pools {
  id: ID!
  ratingBy: ID
  owner: String
  name: String
  rating: Int
  comment: String
  status: RatingStatus
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input UpdateRatingInput {
  id: ID!
  rating: Int
  comment: String
}

enum RatingStatus {
  PENDING
  COMPLETED
}

type ModelRatingConnection @aws_iam @aws_cognito_user_pools {
  items: [Rating]!
  nextToken: String
}

# ****************************************************************************
# PAYTO AGREEMENT
# ****************************************************************************
type PayToAgreement {
  id: ID!
  agreementUuid: ID!
  status: String
  statusDescription: String
  statusReasonCode: String
  statusReasonDescription: String
  entityId: ID!
  fromId: ID!
  from: Entity
  paymentFrequency: PaymentFrequency!
  amount: Int!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

enum PayToAgreementStatus {
  PENDING_VALIDATION
  CANCELLED
  CREATED
  ACTIVE
}

# ****************************************************************************
# REFERRER
# ****************************************************************************
type Referrar @aws_iam @aws_cognito_user_pools {
  userId: ID
  firstName: String
  lastName: String
  code: String
  email: AWSEmail
  referralCount: Int
  referredByUserId: ID
  referredByCode: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  id: ID!
  owner: String
}

# ****************************************************************************
# REFERRAL
# ****************************************************************************
type Referral @aws_iam @aws_cognito_user_pools {
  id: ID!
  userId: ID!
  referredId: ID!
  firstName: String
  lastName: String
  taskPaidCount: Int
  referredByCode: String
  referredCompleted: Boolean
  referredSignedStatus: Boolean
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# ****************************************************************************
# S3UPLOAD
# ****************************************************************************
type S3Upload @aws_iam @aws_cognito_user_pools {
  identityId: String
  key: String!
  level: S3UploadLevel!
  type: S3UploadType!
}

input S3UploadInput {
  identityId: String
  key: String!
  level: S3UploadLevel!
  type: S3UploadType!
}

enum S3UploadType {
  IMAGE
  PDF
  VIDEO
  FILE
}

enum S3UploadLevel {
  public
  protected
  private
}

# ****************************************************************************
# SERVICE
# ****************************************************************************
type Service {
  id: ID!
  entityId: ID!
  title: String!
  description: String
  amount: Int!
  fee: Int!
  feeType: FeeType!
  includesGST: Boolean!
  searchName: String
  status: ServiceStatus!
  createdAt: String!
  updatedAt: String!
}

enum FeeType {
  FIXED
  HOURLY
}

enum ServiceStatus {
  ACTIVE
  ARCHIVED
}

input CreateServiceInput {
  entityId: ID!
  title: String!
  description: String
  amount: Int!
  fee: Int!
  feeType: FeeType!
  includesGST: Boolean!
}

input UpdateServiceInput {
  id: ID!
  title: String
  description: String
  amount: Int
  fee: Int
  feeType: FeeType
  includesGST: Boolean
}

input ModelServiceStatusInput {
  eq: ServiceStatus
  ne: ServiceStatus
}

input ModelServiceFilterInput {
  status: ModelServiceStatusInput
  searchName: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelServiceFilterInput]
  or: [ModelServiceFilterInput]
  not: ModelServiceFilterInput
}

type ModelServiceConnection {
  items: [Service]
  nextToken: String
}

# ****************************************************************************
# SIGNATURE
# ****************************************************************************
type Signature @aws_iam @aws_cognito_user_pools {
  id: ID!
  userId: ID!
  key: String!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input CreateSignatureInput {
  key: String!
}

input DeleteSignatureInput {
  userId: ID!
  createdAt: AWSDateTime!
}

type ModelSignatureConnection {
  items: [Signature]!
  nextToken: String
}

input ModelSignatureFilterInput {
  key: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelSignatureFilterInput]
  or: [ModelSignatureFilterInput]
  not: ModelSignatureFilterInput
}

enum AnnotationStatus {
  PENDING
  ACTIONED
}
# TODO: remove contactIdFrom / to  entityId from / to - ETC

# ****************************************************************************
# TASK
# ****************************************************************************
type Task @aws_iam @aws_cognito_user_pools {
  entityId: ID!
  agreementUuid: ID
  id: ID!
  activity(
    createdAt: ModelStringKeyConditionInput
    filter: ModelActivityFilterInput
    sortDirection: ModelSortDirection
    limit: Int
    nextToken: String
  ): ModelActivityConnection
  amount: Int
  annotations: AWSJSON
  # amountReceived: Int
  # amountOutstanding: Int
  entityIdFrom: ID
  fromId: ID!
  fromType: FromToType!
  toId: ID!
  toType: FromToType!
  entityIdTo: ID
  contactIdFrom: ID
  contactIdTo: ID
  contactId: ID
  fromSearchStatus: String # entityId#TaskSearchStatus
  toSearchStatus: String # entityId#TaskSearchStatus
  entityByIdContactId: String
  searchName: String
  status: TaskStatus!
  signatureStatus: TaskSignatureStatus
  paymentStatus: TaskPaymentStatus
  type: TaskType!
  category: TaskCategory
  documents: [S3Upload]
  numberOfPayments: Int
  paymentFrequency: PaymentFrequency
  paymentTypes: [PaymentType]!
  reference: String
  bpayReferenceNumber: String
  settlementStatus: TaskSettlementStatus
  signers: [EntityUser]
  payments(
    scheduledAt: ModelStringKeyConditionInput
    filter: ModelPaymentFilterInput
    sortDirection: ModelSortDirection
    limit: Int
    nextToken: String
  ): ModelPaymentConnection
  #  taskPayments(
  #    createdAt: ModelStringKeyConditionInput
  #    filter: ModelTaskPaymentFilterInput
  #    sortDirection: ModelSortDirection
  #    limit: Int
  #    nextToken: String
  #  ): ModelTaskPaymentConnection
  createdBy: ID!
  entityIdBy: ID
  dueAt: AWSDate!
  noteForSelf: String
  noteForOther: String
  direction: TaskDirection
  readBy: [ID]
  gstInclusive: Boolean
  paymentAt: AWSDate
  lodgementAt: AWSDate
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  viewedAt: AWSDateTime
  readAt: AWSDateTime
  paidAt: AWSDateTime
  completedAt: AWSDateTime
  owner: String
}

enum FromToType {
  ENTITY
  CONTACT
}

enum TaskSearchStatus {
  INCOMPLETE
  SCHEDULED
  COMPLETED
  ARCHIVED
  DRAFT
}

enum TaskSignatureStatus {
  PENDING_SIGNATURE
  SIGNED
  NOT_SIGNABLE
}

# TODO: remove payment statuses other than scheduled?
enum TaskPaymentStatus {
  PENDING_PAYMENT
  PENDING_TRANSFER
  PENDING_PAYTO_AGREEMENT_CREATION
  PENDING_PAYID_TRANSFER
  PAYTO_AGREEMENT_DECLINED
  SCHEDULED
  PAYID_SCHEDULED
  PAYTO_SCHEDULED
  PAID
  DECLINED
  NOT_PAYABLE
  MARKED_AS_PAID
}

enum TaskType {
  SIGN_PAY
  SIGN_ONLY
  PAY_ONLY
}

enum TaskCategory {
  TAX
  OTHER
}

enum TaskStatus {
  DRAFT
  REVIEW
  INCOMPLETE
  SCHEDULED
  COMPLETED
  ARCHIVED
}

enum PaymentFrequency {
  ONCE
  WEEKLY
  FORTNIGHTLY
  MONTHLY
  QUARTERLY
  ANNUALLY
}

# TODO: make bank / bpay like ContactBpay / ContactBankAccount
input CreateTaskInput {
  fromId: ID!
  fromType: FromToType!
  toId: ID!
  toType: FromToType!
  type: TaskType!
  direction: TaskDirection!
  documents: [S3UploadInput]
  numberOfPayments: Int
  paymentFrequency: PaymentFrequency
  paymentTypes: [PaymentType]
  reference: String!
  bpayReferenceNumber: String
  amount: Int
  gstAmount: Int
  noteForSelf: String
  noteForOther: String
  settlementStatus: TaskSettlementStatus
  signers: [SignerInput]
  annotations: AWSJSON
  dueAt: AWSDate!
  paymentAt: AWSDate
  lodgementAt: AWSDate
  status: CreateTaskStatus
  gstInclusive: Boolean
  # entityIdFrom: ID
  # entityIdTo: ID
  # contactIdFrom: ID
  # contactIdTo: ID
}

enum CreateTaskStatus {
  DRAFT
}

enum TaskSettlementStatus {
  PAYABLE
  REFUNDABLE
}

enum TaskDirection {
  SENDING
  RECEIVING
}

input UpdateTaskInput {
  id: ID!
  entityId: ID!
  paymentStatus: UpdateTaskPaymentStatus
  status: UpdateTaskStatus
  annotations: AWSJSON
  amount: Int
  fromId: ID
  fromType: FromToType
  toId: ID
  toType: FromToType
  direction: TaskDirection
  type: TaskType
  documents: [S3UploadInput]
  paymentTypes: [PaymentType]
  paymentFrequency: PaymentFrequency
  settlementStatus: TaskSettlementStatus
  numberOfPayments: Int
  reference: String
  bpayReferenceNumber: String
  gstAmount: Int
  noteForSelf: String
  noteForOther: String
  signers: [SignerInput]
  gstInclusive: Boolean
  dueAt: AWSDate
  paymentAt: AWSDate
  lodgementAt: AWSDate
}

input UpdateTaskGuestInput {
  id: ID!
  entityId: ID!
  annotations: AWSJSON
}

enum UpdateTaskStatus {
  INCOMPLETE
  ARCHIVED
}

enum UpdateTaskPaymentStatus {
  MARKED_AS_PAID
  PENDING_PAYMENT
}

input SignerInput {
  userId: String
  signerType: SignerType
}

enum SignerType {
  ACCOUNTANT
  ENTITY_USER
}

type ModelTaskConnection @aws_iam @aws_cognito_user_pools {
  items: [Task]!
  nextToken: String
}

input ModelTaskStatusInput {
  eq: TaskStatus
  ne: TaskStatus
}

input ModelTaskFilterInput {
  status: ModelTaskStatusInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelTaskFilterInput]
  or: [ModelTaskFilterInput]
  not: ModelTaskFilterInput
}

input CreateTaskDocumentUrlInput {
  taskId: ID!
  entityId: ID!
}

type TaskDocumentUrl @aws_iam @aws_cognito_user_pools {
  url: String
  expiresAt: AWSDateTime
}

# ****************************************************************************
# TASK GUEST
# ****************************************************************************
type TaskGuest @aws_iam @aws_cognito_user_pools {
  id: ID!
  entityId: ID!
  amount: Int
  annotations: AWSJSON
  fromId: ID!
  fromEntity: EntityGuest
  from: EntityGuest
  fromContact: ContactGuest
  fromType: FromToType!
  toEntity: EntityGuest
  toContact: ContactGuest
  toId: ID!
  to: EntityGuest
  toType: FromToType!
  status: TaskStatus!
  signatureStatus: TaskSignatureStatus
  paymentStatus: TaskPaymentStatus
  settlementStatus: TaskSettlementStatus
  type: TaskType!
  category: TaskCategory
  documents: [S3Upload]
  numberOfPayments: Int
  paymentFrequency: PaymentFrequency
  paymentTypes: [PaymentType]!
  reference: String
  bpayReferenceNumber: String
  createdBy: ID!
  gstInclusive: Boolean
  entityIdBy: ID
  dueAt: AWSDate!
  noteForOther: String
  direction: TaskDirection
  paymentAt: AWSDate
  lodgementAt: AWSDate
  readAt: AWSDateTime
  paidAt: AWSDateTime
  completedAt: AWSDateTime
  owner: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# ****************************************************************************
# TASK PAYMENTS
# ****************************************************************************
# type TaskPayment @aws_iam @aws_cognito_user_pools {
#  id: ID!
#  taskId: ID!
#  paymentId: ID!
#  payment: Payment
#  createdAt: AWSDateTime
#  updatedAt: AWSDateTime
#}

#input ModelTaskPaymentFilterInput {
#  createdAt: ModelStringInput
#  updatedAt: ModelStringInput
#  and: [ModelTaskPaymentFilterInput]
#  or: [ModelTaskPaymentFilterInput]
#  not: ModelTaskPaymentFilterInput
#}

#type ModelTaskPaymentConnection @aws_iam @aws_cognito_user_pools {
#  items: [TaskPayment]!
#  nextToken: String
#}

# ****************************************************************************
# TEMPLATE
# ****************************************************************************
type Template {
  id: ID!
  entityId: ID!
  title: String!
  templateServices(
    sortDirection: ModelSortDirection
    limit: Int
    nextToken: String
  ): ModelTemplateServiceConnection
  components: [TemplateComponent]
  searchName: String
  status: TemplateStatus!
  createdAt: String!
  updatedAt: String!
}

enum ComponentType {
  LETTERHEAD
  TEXT
  SERVICES
  BANK_DETAILS
  SIGNATURE
}

type TemplateComponent {
  type: ComponentType!
  data: AWSJSON
}

enum TemplateStatus {
  ACTIVE
  ARCHIVED
}

type ModelTemplateServiceConnection {
  items: [TemplateService]
  nextToken: String
}

input CreateTemplateInput {
  entityId: ID!
  title: String!
  status: TemplateStatus!
}

input UpdateTemplateInput {
  id: ID!
  title: String
  status: TemplateStatus
  components: [TemplateComponentInput]
}

input TemplateComponentInput {
  type: ComponentType!
  data: AWSJSON
}

input ModelTemplateStatusInput {
  eq: TemplateStatus
  ne: TemplateStatus
}

input ModelTemplateFilterInput {
  status: ModelTemplateStatusInput
  searchName: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelTemplateFilterInput]
  or: [ModelTemplateFilterInput]
  not: ModelTemplateFilterInput
}

type ModelTemplateConnection {
  items: [Template]
  nextToken: String
}

# ****************************************************************************
# TEMPLATE SERVICE
# ****************************************************************************
type TemplateService {
  templateId: ID!
  serviceId: ID!
  service: Service
  createdAt: String!
  updatedAt: String!
}

input CreateTemplateServiceInput {
  templateId: ID!
  serviceId: ID!
}

input DeleteTemplateServiceInput {
  templateId: ID!
  serviceId: ID!
}

# ****************************************************************************
# TRANSACTION
# ****************************************************************************
type Transaction @aws_iam @aws_cognito_user_pools {
  id: ID!
  amount: Int
  currency: String
  description: String
  status: String
  type: String
  typeMethod: String
  buyerId: ID
  taskId: ID
  entityId: ID
  referredBy: ID
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# ****************************************************************************
# TRANSLATIONS
# ****************************************************************************
type Translation {
  language: String!
  namespace: String!
  data: AWSJSON
}

type TranslationConnection {
  language: String
  items: [Translation]
}

input CreateTranslationInput {
  language: String
  namespace: String
  name: String
  value: String
}

input UpdateTranslationInput {
  language: String
  namespace: String
  data: AWSJSON
}

type ModelTransactionConnection @aws_iam @aws_cognito_user_pools {
  items: [Transaction]!
  nextToken: String
}

input ModelTransactionFilterInput {
  userId: ModelStringInput
  purchaseToken: ModelStringInput
  expiresAt: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelTransactionFilterInput]
  or: [ModelTransactionFilterInput]
  not: ModelTransactionFilterInput
}

# TODO: remove providerWalletId, onboardingEntity
# ****************************************************************************
# USER
# ****************************************************************************
type User @aws_iam @aws_cognito_user_pools {
  id: ID!
  identityId: ID
  referralCode: String
  referredBy: ID
  email: AWSEmail
  about: String
  firstName: String
  firmId: ID
  lastName: String
  phone: AWSPhone
  blocked: [String]
  blockedBy: [String]
  country: String
  profileImg: Image
  interests: [String]
  locale: String
  onboardingStatus: OnboardingStatus
  onboardingEntity: ID
  selectedSignatureKey: ID
  signatures(
    filter: ModelSignatureFilterInput
    sortDirection: ModelSortDirection
    limit: Int
    nextToken: String
  ): ModelSignatureConnection
  userType: UserType
  rating: Int
  # ratings: [Rating]
  reportReasons: [String]
  notificationPreferences: NotificationPreferences
  paymentUserId: ID
  providerWalletId: ID
  providerNppCrn: String
  ipAddress: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  owner: String
  loyaltyStatus: RewardStatus
  nextLoyaltyStatus: RewardStatus
  nextLoyaltyStatusPoint: Int
  statusPoint: Int
  pointsTotal: Int
  pointsBalance: Int
  invitedTo: ID
}

type ModelReferralConnection @aws_iam @aws_cognito_user_pools {
  items: [Referral]!
  nextToken: String
}

enum OnboardingStatus {
  PROFILE
  BUSINESS
  PLANS
  COMPLETED
}

enum UserType {
  Buyers
  Sellers
}

input BlockUserInput {
  userId: String
  reason: ReportReason
}

input ReportUserInput {
  userId: String
  reason: ReportReason
}

enum ReportReason {
  SPAM
  OFFENSIVE
}

input UpdateUserInput {
  id: ID!
  about: String
  firstName: String
  lastName: String
  country: String
  profileImg: ImageInput
  interests: [String]
  locale: String
  onboardingStatus: OnboardingStatus
  onboardingEntity: ID
  userType: UserType
  notificationPreferences: NotificationPreferencesInput
  selectedSignatureKey: ID
  email: AWSEmail
  phone: AWSPhone
}

type NotificationPreferences {
  email: Boolean
  push: Boolean
  sms: Boolean
}

input NotificationPreferencesInput {
  email: Boolean
  push: Boolean
  sms: Boolean
}

type ModelUserConnection @aws_iam @aws_cognito_user_pools {
  items: [User]!
  nextToken: String
}

input ModelOnboardingStatusInput {
  eq: OnboardingStatus
  ne: OnboardingStatus
}

input ModelUserTypeInput {
  eq: UserType
  ne: UserType
}

input ModelUserFilterInput {
  id: ModelIDInput
  identityId: ModelIDInput
  email: ModelStringInput
  about: ModelStringInput
  firstName: ModelStringInput
  lastName: ModelStringInput
  phone: ModelStringInput
  blocked: ModelStringInput
  blockedBy: ModelStringInput
  country: ModelStringInput
  interests: ModelStringInput
  locale: ModelStringInput
  onboardingStatus: ModelOnboardingStatusInput
  onboardingEntity: ModelIDInput
  userType: ModelUserTypeInput
  reportReasons: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelUserFilterInput]
  or: [ModelUserFilterInput]
  not: ModelUserFilterInput
}

# ****************************************************************************
# USER CONVERSATION
# ****************************************************************************
type UserConversation @aws_iam @aws_cognito_user_pools {
  conversationId: ID!
  conversation: Conversation
  userId: ID!
  user: User
  users: [String]
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  id: ID!
  conversationUserConversationsId: ID
}

type ModelUserConversationConnection @aws_iam @aws_cognito_user_pools {
  items: [UserConversation]!
  nextToken: String
}

input ModelUserConversationFilterInput {
  conversationId: ModelIDInput
  userId: ModelIDInput
  users: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelUserConversationFilterInput]
  or: [ModelUserConversationFilterInput]
  not: ModelUserConversationFilterInput
  conversationUserConversationsId: ModelIDInput
}

input ModelUserConversationConditionInput {
  conversationId: ModelIDInput
  userId: ModelIDInput
  users: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelUserConversationConditionInput]
  or: [ModelUserConversationConditionInput]
  not: ModelUserConversationConditionInput
  conversationUserConversationsId: ModelIDInput
}

input CreateUserConversationInput {
  conversationId: ID!
  userId: ID!
  users: [String]
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  id: ID
  conversationUserConversationsId: ID
}

input UpdateUserConversationInput {
  conversationId: ID
  userId: ID
  users: [String]
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  id: ID!
  conversationUserConversationsId: ID
}

input DeleteUserConversationInput {
  id: ID!
}

input ModelSubscriptionUserConversationFilterInput {
  conversationId: ModelSubscriptionIDInput
  userId: ModelSubscriptionIDInput
  createdAt: ModelSubscriptionStringInput
  updatedAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionUserConversationFilterInput]
  or: [ModelSubscriptionUserConversationFilterInput]
}

# ****************************************************************************
# WALLET
# ****************************************************************************
type Wallet @aws_iam @aws_cognito_user_pools {
  id: ID!
  owner: ID!
  balance: Int
  currency: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# ****************************************************************************
# XERO
# ****************************************************************************
type XeroAddress {
  addressType: String
  addressLine1: String
  addressLine2: String
  addressLine3: String
  addressLine4: String
  city: String
  region: String
  postalCode: String
  country: String
  attentionTo: String
}

input XeroCreateConsentUrlInput {
  scopeSet: XeroScopeSet!
}

type XeroContact {
  contactID: ID!
  contactNumber: String
  accountNumber: String
  contactStatus: String
  name: String
  firstName: String
  lastName: String
  companyNumber: String
  emailAddress: String
  bankAccountDetails: String
  taxNumber: String
  accountsReceivableTaxType: String
  accountsPayableTaxType: String
  addresses: [XeroAddress]
  phones: [XeroPhone]
  isSupplier: Boolean
  isCustomer: Boolean
  defaultCurrency: String
  updatedDateUTC: String
  contactPersons: [XeroContactPerson]
  hasAttachments: Boolean
  xeroNetworkKey: String
  salesDefaultAccountCode: String
  purchasesDefaultAccountCode: String
  # salesTrackingCategories: [XeroTrackingCategory]
  # purchasesTrackingCategories: [XeroTrackingCategory]
  trackingCategoryName: String
  trackingCategoryOption: String
  paymentTerms: String
  # contactGroups: [XeroContactGroup]
  website: String
  # brandingTheme: XeroBrandingTheme
  # batchPayments: XeroBatchPayment
  discount: Float
  # balances: XeroBalances
}

type XeroContactPerson {
  firstName: String
  lastName: String
  emailAddress: String
  includeInEmails: Boolean
}

input XeroCreateTokenSetInput {
  url: String!
  scopeSet: XeroScopeSet!
}

type XeroCreateTokenSetResponse {
  token: String
  expiresIn: Int
  user: XeroCreateTokenSetUser
}

type XeroCreateTokenSetUser {
  email: String
  givenName: String
  familyName: String
}

enum XeroScopeSet {
  PROFILE
  ACCOUNTING
}

type XeroInvoice {
  invoiceID: ID!
  type: String
  status: XeroInvoiceStatus
  lineAmountTypes: String
  currencyCode: String
  date: String
  dueDate: String
  lineItems: [XeroLineItem]
  subTotal: Float
  totalTax: Float
  total: Float
  invoiceNumber: String
  reference: String
  hasAttachments: Boolean
  updatedDateUTC: String
  currencyRate: Float
  remainingCredit: Float
  # allocations: [XeroAllocation]
  amountDue: Float
  amountPaid: Float
  fullyPaidOnDate: String
  amountCredited: Float
  brandingThemeID: String
  hasErrors: Boolean
  contact: XeroContact
  # payments: [XeroPayment]
  # prepayments: [XeroPrepayment]
  # overpayments: [XeroOverpayment]
}

enum XeroInvoiceStatus {
  DRAFT
  SUBMITTED
  DELETED
  AUTHORISED
  PAID
  VOIDED
}

type XeroLineItem {
  lineItemID: ID!
  description: String
  quantity: Float
  unitAmount: Float
  itemCode: String
  accountCode: String
  accountID: String
  taxType: String
  taxAmount: Float
  lineAmount: Float
  taxNumber: Float
  # item: XeroLineItemItem
  # tracking: [XeroLineItemTracking]
  discountRate: Float
  discountAmount: Float
  repeatingInvoiceID: String
}

type XeroPhone {
  phoneType: String
  phoneNumber: String
  phoneAreaCode: String
  phoneCountryCode: String
}

# ****************************************************************************
# ZAI
# ****************************************************************************
type CreatePaymentMethodToken @aws_iam @aws_cognito_user_pools {
  token: String
  userId: String
}

input CreatePaymentMethodTokenInput {
  tokenType: PaymentTokenType!
  isGuest: Boolean
  taskId: ID
  entityId: ID
}

input CreatePayToAgreementInput {
  agreementUuids: [ID!]!
  billPayments: [BillsPaymentInput!]!
}

input TaskIdInput {
  id: ID!
  entityId: ID!
}

enum PaymentTokenType {
  card
  bank
}

input ValidatePayToAgreementInput {
  accountNumber: String!
  bsb: String!
  description: String
  entityId: ID!
  billPayments: [BillsPaymentInput!]!
}

input GetUpdatePayToAgreementInput {
  agreementUuid: ID!
}

type ProviderPayToFailedPayment {
  id: ID!
  agreementUuid: ID!
  errorMessage: String
}

# ****************************************************************************
# QUERIES
# ****************************************************************************

type Query {
  # ABR
  abrLookup(abn: String): ABNInformation! @aws_iam @aws_cognito_user_pools
  abrLookupByName(name: String): ModelAbrNameSearchInformationConnection!
    @aws_iam
    @aws_cognito_user_pools

  # ADMINS
  getAdmin(id: ID!): Admin
    @aws_iam
    @aws_cognito_user_pools(cognito_groups: ["SuperAdmins"])
  listAdmins(
    filter: ModelAdminFilterInput
    limit: Int
    nextToken: String
  ): ModelAdminConnection
    @aws_iam
    @aws_cognito_user_pools(cognito_groups: ["SuperAdmins"])

  # AUTOCOMPLETE RESULTS
  autocompleteResultsByType(
    type: AutocompleteType!
    searchName: String!
    sortDirection: ModelSortDirection
    filter: ModelEntityFilterInput
    limit: Int
    nextToken: String
  ): ModelAutocompleteResultConnection @aws_iam @aws_cognito_user_pools
  getAutoComplete(id: ID!): GetAutoCompleteResult
    @aws_iam
    @aws_cognito_user_pools

  # CHAT

  # CONTACTS
  getContact(id: ID!): Contact @aws_iam @aws_cognito_user_pools
  contactsByEntity(
    entityId: ID!
    sortDirection: ModelSortDirection
    filter: ModelContactFilterInput
    nextToken: String
  ): ModelContactConnection
    @aws_iam
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])

  # CONVERSATIONS
  getConversation(id: ID!): Conversation @aws_iam @aws_cognito_user_pools
  listConversations(
    filter: ModelConversationFilterInput
    limit: Int
    nextToken: String
  ): ModelConversationConnection @aws_iam @aws_cognito_user_pools

  # DOCUMENT ANALYSIS
  getDocumentAnalysis(id: ID!): DocumentAnalysis
    @aws_iam
    @aws_cognito_user_pools

  # ENTITIES
  getEntity(id: ID!): Entity @aws_iam @aws_cognito_user_pools

  # ENTITY USER
  entityUsersByUser(
    sortDirection: ModelSortDirection
    filter: ModelEntityUserFilterInput
    limit: Int
    nextToken: String
  ): ModelEntityUserConnection @aws_iam @aws_cognito_user_pools

  entityUsersByEntityId(
    entityId: ID
    sortDirection: ModelSortDirection
    filter: ModelEntityUserFilterInput
    limit: Int
    nextToken: String
  ): ModelEntityUserConnection @aws_iam @aws_cognito_user_pools

  # FRANKIEONE
  getBusinessLookup(query: String): [BusinessLookupResult]!
    @aws_iam
    @aws_cognito_user_pools

  # MESSAGES
  getMessage(id: ID!): Message @aws_iam @aws_cognito_user_pools
  listMessages(
    filter: ModelMessageFilterInput
    limit: Int
    nextToken: String
  ): ModelMessageConnection @aws_iam @aws_cognito_user_pools
  messagesByConversation(
    conversationId: ID!
    createdAt: ModelStringKeyConditionInput
    sortDirection: ModelSortDirection
    filter: ModelMessageFilterInput
    limit: Int
    nextToken: String
  ): ModelMessageConnection @aws_iam @aws_cognito_user_pools

  # NOTIFICATIONS
  notificationsByUser(
    sortDirection: ModelSortDirection
    filter: ModelNotificationFilterInput
    limit: Int
    nextToken: String
  ): ModelNotificationConnection @aws_iam @aws_cognito_user_pools

  # OPTIONS
  getOption(id: ID!): Option @aws_iam @aws_cognito_user_pools
  listOptions(
    filter: ModelOptionFilterInput
    limit: Int
    nextToken: String
  ): ModelOptionConnection @aws_iam @aws_cognito_user_pools
  optionsByName(
    name: String!
    label: ModelStringKeyConditionInput
    sortDirection: ModelSortDirection
    filter: ModelOptionFilterInput
    limit: Int
    nextToken: String
  ): ModelOptionConnection @aws_iam @aws_cognito_user_pools
  optionsByGroup(
    group: String!
    label: ModelStringKeyConditionInput
    sortDirection: ModelSortDirection
    filter: ModelOptionFilterInput
    limit: Int
    nextToken: String
  ): ModelOptionConnection @aws_iam @aws_cognito_user_pools

  # PAYMENTS
  getPaymentGuest(id: ID!): PaymentGuest @aws_iam @aws_cognito_user_pools

  # RATINGS
  listRatingsByUser(
    userId: String!
    sortDirection: ModelSortDirection
    filter: ModelTransactionFilterInput
    limit: Int
    nextToken: String
  ): ModelRatingConnection @aws_iam @aws_cognito_user_pools

  # SERVICES
  getService(id: ID!): Service @aws_iam @aws_cognito_user_pools
  servicesByEntity(
    entityId: ID!
    sortDirection: ModelSortDirection
    filter: ModelServiceFilterInput
    limit: Int
    nextToken: String
  ): ModelServiceConnection @aws_iam @aws_cognito_user_pools

  # TASKS
  getTask(id: ID!, entityId: ID!): Task @aws_iam @aws_cognito_user_pools
  getTaskGuest(id: ID!, entityId: ID!): TaskGuest
    @aws_iam
    @aws_cognito_user_pools
  tasksByEntityFrom(
    entityId: ID!
    status: TaskSearchStatus!
    sortDirection: ModelSortDirection
    filter: ModelTaskFilterInput
    limit: Int
    nextToken: String
  ): ModelTaskConnection @aws_iam @aws_cognito_user_pools
  tasksByEntityTo(
    entityId: ID!
    status: TaskSearchStatus!
    sortDirection: ModelSortDirection
    filter: ModelTaskFilterInput
    limit: Int
    nextToken: String
  ): ModelTaskConnection @aws_iam @aws_cognito_user_pools

  tasksByEntityByIdContactId(
    entityIdBy: ID!
    contactId: ID!
    # status: TaskSearchStatus!
    sortDirection: ModelSortDirection
    filter: ModelTaskFilterInput
    limit: Int
    nextToken: String
  ): ModelTaskConnection @aws_iam @aws_cognito_user_pools

  tasksByEntityBy(
    entityIdBy: ID!
    status: TaskSearchStatus!
    sortDirection: ModelSortDirection
    filter: ModelTaskFilterInput
    limit: Int
    nextToken: String
  ): ModelTaskConnection @aws_iam @aws_cognito_user_pools

  # tasks by searchName
  searchTasks(
    searchName: String!
    sortDirection: ModelSortDirection
    filter: ModelTaskFilterInput
    limit: Int
    nextToken: String
  ): ModelTaskConnection @aws_iam @aws_cognito_user_pools

  # TASK PAYMENTS
  # taskPaymentsByTask(
  #  taskId: ID!
  #  scheduledAt: ModelStringKeyConditionInput
  #  sortDirection: ModelSortDirection
  #  filter: ModelTaskPaymentFilterInput
  #  limit: Int
  #  nextToken: String
  #): ModelTaskPaymentConnection @aws_iam @aws_cognito_user_pools

  # TRANSACTIONS
  getTransaction(id: ID!): Transaction @aws_iam @aws_cognito_user_pools
  listTransactions(
    filter: ModelTransactionFilterInput
    limit: Int
    nextToken: String
  ): ModelTransactionConnection @aws_iam @aws_cognito_user_pools
  transactionsByUserIdAndCreatedAt(
    userId: String!
    createdAt: ModelStringKeyConditionInput
    sortDirection: ModelSortDirection
    filter: ModelTransactionFilterInput
    limit: Int
    nextToken: String
  ): ModelTransactionConnection @aws_iam @aws_cognito_user_pools
  transactionsByPurchaseTokenAndCreatedAt(
    purchaseToken: String!
    createdAt: ModelStringKeyConditionInput
    sortDirection: ModelSortDirection
    filter: ModelTransactionFilterInput
    limit: Int
    nextToken: String
  ): ModelTransactionConnection @aws_iam @aws_cognito_user_pools

  # TEMPLATES
  getTemplate(id: ID!): Template @aws_iam @aws_cognito_user_pools
  templatesByEntity(
    entityId: ID!
    sortDirection: ModelSortDirection
    filter: ModelTemplateFilterInput
    limit: Int
    nextToken: String
  ): ModelTemplateConnection @aws_iam @aws_cognito_user_pools

  # TRANSLATIONS
  getTranslation(language: String, namespace: String): Translation
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins"])
  listTranslations: [TranslationConnection]
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins"])

  # USER CONVERSATIONS
  getUserConversation(id: ID!): UserConversation
    @aws_iam
    @aws_cognito_user_pools
  listUserConversations(
    filter: ModelUserConversationFilterInput
    limit: Int
    nextToken: String
  ): ModelUserConversationConnection @aws_iam @aws_cognito_user_pools
  userConversationsByConversationIdAndCreatedAt(
    conversationId: ID!
    createdAt: ModelStringKeyConditionInput
    sortDirection: ModelSortDirection
    filter: ModelUserConversationFilterInput
    limit: Int
    nextToken: String
  ): ModelUserConversationConnection @aws_iam @aws_cognito_user_pools
  userConversationsByUserId(
    userId: ID!
    sortDirection: ModelSortDirection
    filter: ModelUserConversationFilterInput
    limit: Int
    nextToken: String
  ): ModelUserConversationConnection @aws_iam @aws_cognito_user_pools

  # USERS
  getUser(id: ID!): User @aws_iam @aws_cognito_user_pools
  listUsers(
    id: ID
    filter: ModelUserFilterInput
    limit: Int
    nextToken: String
    sortDirection: ModelSortDirection
  ): ModelUserConnection @aws_iam @aws_cognito_user_pools

  getActivitiesByUser(
    id: ID!
    filter: ModelActivityFilterInput
    limit: Int
    nextToken: String
    sortDirection: ModelSortDirection
  ): ModelActivityConnection @aws_iam @aws_cognito_user_pools

  getReferralsByUser(
    id: ID!
    limit: Int
    nextToken: String
    sortDirection: ModelSortDirection
  ): ModelReferralConnection @aws_iam @aws_cognito_user_pools

  # XERO
  xeroListContacts(page: Int): [XeroContact] @aws_cognito_user_pools
  xeroListTransactions(statuses: [XeroInvoiceStatus], page: Int): [XeroInvoice]
    @aws_cognito_user_pools

  # Zai
  getPayToFailedPayment(instructionId: String!): ProviderPayToFailedPayment
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])

  # TODO: refactor name, other uses?
  getEntityPayId(entityId: ID!, billPayments: [BillsPaymentInput]): EntityPayId
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])
}

# ****************************************************************************
# MUTATIONS
# ****************************************************************************
type Mutation {
  # ADMINS
  createAdmin(input: CreateAdminInput): Admin
    @aws_cognito_user_pools(cognito_groups: ["SuperAdmins"])
  updateAdmin(
    input: UpdateAdminInput!
    condition: ModelAdminConditionInput
  ): Admin @aws_iam @aws_cognito_user_pools(cognito_groups: ["SuperAdmins"])
  deleteAdmin(input: DeleteAdminInput): Admin
    @aws_cognito_user_pools(cognito_groups: ["SuperAdmins"])

  # beneficial owner
  updateBeneficialOwner(input: UpdateBeneficialOwnerInput): BeneficialOwner
    @aws_iam
  # CLIENT
  createClient(input: CreateClientInput): EntityUser
    @aws_iam
    @aws_cognito_user_pools

  # CONTACT
  createContact(input: CreateContactInput!): Contact
    @aws_iam
    @aws_cognito_user_pools
  createContactBulkUpload(input: CreateContactBulkImportInput!): AWSJSON
    @aws_iam
    @aws_cognito_user_pools
  updateContact(input: UpdateContactInput!): Contact
    @aws_iam
    @aws_cognito_user_pools

  # CONVERSATIONS
  createConversation(
    input: CreateConversationInput!
    condition: ModelConversationConditionInput
  ): Conversation @aws_iam @aws_cognito_user_pools
  updateConversation(
    input: UpdateConversationInput!
    condition: ModelConversationConditionInput
  ): Conversation @aws_iam @aws_cognito_user_pools
  deleteConversation(
    input: DeleteConversationInput!
    condition: ModelConversationConditionInput
  ): Conversation @aws_iam @aws_cognito_user_pools

  # DOCUMENT ANALYSIS
  createDocumentAnalysis(
    input: CreateDocumentAnalysisInput
  ): [DocumentAnalysis] @aws_iam @aws_cognito_user_pools

  # ENTITY
  createEntity(input: CreateEntityInput!): Entity
    @aws_iam
    @aws_cognito_user_pools

  updateEntity(input: UpdateEntityInput!): Entity
    @aws_iam
    @aws_cognito_user_pools

  regenerateEntityOcrEmail(input: RegenerateEntityOcrEmailInput!): Entity
    @aws_iam
    @aws_cognito_user_pools

  deleteEntity(
    input: DeleteEntityInput!
    condition: ModelEntityConditionInput
  ): Entity @aws_iam @aws_cognito_user_pools

  # ENTITY USER
  createEntityUser(input: CreateEntityUserInput!): EntityUser
    @aws_iam
    @aws_cognito_user_pools

  updateEntityUser(input: UpdateEntityUserInput!): EntityUser
    @aws_iam
    @aws_cognito_user_pools

  acceptDenyEntityUserStatus(
    input: AcceptDenyEntityUserStatusInput!
  ): EntityUser @aws_iam @aws_cognito_user_pools

  sendReferralInvitationEmail(
    input: sendReferralInvitationEmailInput!
  ): Boolean @aws_iam @aws_cognito_user_pools

  deleteEntityUser(input: DeleteEntityUserInput): EntityUser
    @aws_iam
    @aws_cognito_user_pools

  # FRANKIEONE
  createVerificationToken(
    input: CreateVerificationTokenInput
  ): VerificationUiToken @aws_iam @aws_cognito_user_pools
  lookupEntityOwnership(
    input: LookupEntityOwnershipInput
  ): LookupEntityOwnershipResult @aws_iam @aws_cognito_user_pools

  # SERVICES
  createService(input: CreateServiceInput!): Service
  updateService(input: UpdateServiceInput!): Service

  # TEMPLATES
  createTemplate(input: CreateTemplateInput!): Template
    @aws_iam
    @aws_cognito_user_pools
  updateTemplate(input: UpdateTemplateInput!): Template
    @aws_iam
    @aws_cognito_user_pools

  # TEMPLATE SERVICE
  createTemplateService(input: CreateTemplateServiceInput!): TemplateService
    @aws_iam
    @aws_cognito_user_pools
  deleteTemplateService(input: DeleteTemplateServiceInput!): TemplateService
    @aws_iam
    @aws_cognito_user_pools

  # MESSAGES
  createMessage(
    input: CreateMessageInput!
    condition: ModelMessageConditionInput
  ): Message @aws_iam @aws_cognito_user_pools
  updateMessage(
    input: UpdateMessageInput!
    condition: ModelMessageConditionInput
  ): Message @aws_iam @aws_cognito_user_pools

  # NOTIFICATIONS
  createNotification(input: CreateNotificationInput): Notification @aws_iam
  updateNotification(input: UpdateNotificationInput): Notification
    @aws_iam
    @aws_cognito_user_pools

  # OPTIONS
  createOption(
    input: CreateOptionInput!
    condition: ModelOptionConditionInput
  ): Option @aws_iam @aws_cognito_user_pools
  updateOption(
    input: UpdateOptionInput!
    condition: ModelOptionConditionInput
  ): Option @aws_iam @aws_cognito_user_pools
  deleteOption(
    input: DeleteOptionInput!
    condition: ModelOptionConditionInput
  ): Option @aws_iam @aws_cognito_user_pools

  # PAYMENTS
  confirmPayments(input: ConfirmPaymentInput): [Payment]
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])

  createPayment(input: CreatePaymentInput): [Payment]
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])

  createPaymentPayId(input: CreatePaymentPayIdInput): PayInPayment
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])

  cancelPaymentPayId(input: CancelPaymentPayIdInput): [Payment]
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])

  retryPayment(input: RetryPaymentInput): [Payment]
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])

  createTaskPayment(input: CreateTaskPaymentInput): [Payment]
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])

  createPaymentGuest(input: CreatePaymentGuestInput): [PaymentGuest]
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])
    @aws_iam

  createPaymentScheduledGuest(
    input: CreatePaymentScheduledGuestInput
  ): [PaymentGuest]
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])
    @aws_iam

  # PAYMENT METHODS
  createPaymentMethod(input: CreatePaymentMethodInput): PaymentMethod
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])

  updatePaymentMethod(input: UpdatePaymentMethodInput): PaymentMethod
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])

  # PUSH NOTIFICATIONS
  createPushNotification(input: CreatePushNotificationInput): AWSJSON
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins"])

  # RATING
  updateRating(input: UpdateRatingInput): Rating
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])

  # SIGNATURE
  createSignature(input: CreateSignatureInput): Signature
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])
  deleteSignature(input: DeleteSignatureInput): Signature

  # TASKS
  createTask(input: CreateTaskInput): Task
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])
  updateTask(input: UpdateTaskInput): Task
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])
  updateTaskGuest(input: UpdateTaskGuestInput): TaskGuest
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])
    @aws_iam
  createTaskDocumentUrl(input: CreateTaskDocumentUrlInput): TaskDocumentUrl
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])
    @aws_iam
  createTaskDocumentUrlGuest(
    input: CreateTaskDocumentUrlInput
  ): TaskDocumentUrl
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])
    @aws_iam

  # TRANSLATIONS
  createTranslation(input: CreateTranslationInput): Translation
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins"])
  updateTranslation(input: UpdateTranslationInput): Translation
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins"])

  # USERS
  updateUser(input: UpdateUserInput): User @aws_cognito_user_pools
  blockUser(input: BlockUserInput): User @aws_cognito_user_pools
  deleteAccount: User @aws_cognito_user_pools

  # USER CONVERSATIONS
  createUserConversation(
    input: CreateUserConversationInput!
    condition: ModelUserConversationConditionInput
  ): UserConversation @aws_iam @aws_cognito_user_pools
  updateUserConversation(
    input: UpdateUserConversationInput!
    condition: ModelUserConversationConditionInput
  ): UserConversation @aws_iam @aws_cognito_user_pools
  deleteUserConversation(
    input: DeleteUserConversationInput!
    condition: ModelUserConversationConditionInput
  ): UserConversation @aws_iam @aws_cognito_user_pools

  publishUserMessage(userId: ID!): Message
  # validateUserIAPReceipt(input: VerifyIAPInput):  @aws_cognito_user_pools

  # XERO
  xeroCreateConsentUrl(input: XeroCreateConsentUrlInput): String
    @aws_iam
    @aws_cognito_user_pools
  xeroCreateTokenSet(input: XeroCreateTokenSetInput): String
    @aws_iam
    @aws_cognito_user_pools

  # ZAI
  getUpdatePayToAgreement(input: GetUpdatePayToAgreementInput!): PayToAgreement
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])
  createPaymentMethodToken(
    input: CreatePaymentMethodTokenInput
  ): CreatePaymentMethodToken
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])
    @aws_iam
  createPayToAgreement(input: CreatePayToAgreementInput): [PayToAgreement]
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])
  validatePayToAgreement(input: ValidatePayToAgreementInput): [PayToAgreement]
    @aws_cognito_user_pools(cognito_groups: ["Admins", "SuperAdmins", "Users"])
}

# ****************************************************************************
# SUBSCRIPTIONS
# ****************************************************************************
type Subscription {
  # BENEFICIAL OWNER
  onUpdateBeneficialOwner(
    beneficialOwnerId: ID!
    entityId: ID!
  ): BeneficialOwner
    @aws_subscribe(mutations: ["updateBeneficialOwner"])
    @aws_iam
    @aws_cognito_user_pools

  # CONVERSATION
  onCreateConversation(
    filter: ModelSubscriptionConversationFilterInput
  ): Conversation
    @aws_subscribe(mutations: ["createConversation"])
    @aws_iam
    @aws_cognito_user_pools

  # FRANKIEONE
  onUpdateEntity(entityId: ID!): Entity
    @aws_subscribe(mutations: ["updateEntity"])
    @aws_iam
    @aws_cognito_user_pools

  # MESSAGES
  onCreateMessageForConversation(conversationId: ID!): Message
    @aws_subscribe(mutations: ["createMessage"])
    @aws_cognito_user_pools(cognito_groups: ["Users", "Admins", "SuperAdmins"])

  # NOTIFICATIONS
  onCreateNotification: Notification
    @aws_subscribe(mutations: ["createNotification"])
    @aws_iam
    @aws_cognito_user_pools

  # USER CONVERSATIONS
  onCreateUserConversationForUser(userId: ID!): UserConversation
    @aws_subscribe(mutations: ["createUserConversation"])
    @aws_cognito_user_pools(cognito_groups: ["Users", "Admins", "SuperAdmins"])
  onCreateMessageForSenderUser(sender: String!): Message
    @aws_subscribe(mutations: ["createMessage"])
  onCreateMessageForReceiverUser(receiver: String!): Message
    @aws_subscribe(mutations: ["createMessage"])
  onUpdateConversation(
    filter: ModelSubscriptionConversationFilterInput
  ): Conversation
    @aws_subscribe(mutations: ["updateConversation"])
    @aws_iam
    @aws_cognito_user_pools
  onDeleteConversation(
    filter: ModelSubscriptionConversationFilterInput
  ): Conversation
    @aws_subscribe(mutations: ["deleteConversation"])
    @aws_iam
    @aws_cognito_user_pools
  onCreateUserConversation(
    filter: ModelSubscriptionUserConversationFilterInput
  ): UserConversation
    @aws_subscribe(mutations: ["createUserConversation"])
    @aws_iam
    @aws_cognito_user_pools
  onUpdateUserConversation(
    filter: ModelSubscriptionUserConversationFilterInput
  ): UserConversation
    @aws_subscribe(mutations: ["updateUserConversation"])
    @aws_iam
    @aws_cognito_user_pools
  onDeleteUserConversation(
    filter: ModelSubscriptionUserConversationFilterInput
  ): UserConversation
    @aws_subscribe(mutations: ["deleteUserConversation"])
    @aws_iam
    @aws_cognito_user_pools
  onCreateMessage(filter: ModelSubscriptionMessageFilterInput): Message
    @aws_subscribe(mutations: ["createMessage"])
    @aws_iam
    @aws_cognito_user_pools
  onUpdateMessage(filter: ModelSubscriptionMessageFilterInput): Message
    @aws_subscribe(mutations: ["updateMessage"])
    @aws_iam
    @aws_cognito_user_pools
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelSubscriptionStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  in: [String]
  notIn: [String]
}

input ModelSubscriptionIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  in: [Int]
  notIn: [Int]
}

input ModelSubscriptionFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  in: [Float]
  notIn: [Float]
}

input ModelSubscriptionBooleanInput {
  ne: Boolean
  eq: Boolean
}

input ModelSubscriptionIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  in: [ID]
  notIn: [ID]
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

input ModelStringKeyConditionInput {
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  between: [String]
  beginsWith: String
}
